        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>QrCode class / bot_qr Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="bot_qr" data-type="QrCode">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../bot_qr.html">bot_qr</a> &rsaquo; <a href="../bot_qr/QrCode.html">QrCode</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>QrCode</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class QrCode {
  static final int _PAD0 = 0xEC;
  static final int _PAD1 = 0x11;

  final typeNumber;
  final errorCorrectLevel;
  final int moduleCount;
  final List&lt;List&gt; _modules;
  List&lt;int&gt; _dataCache;
  List&lt;QrByte&gt; _dataList;

  QrCode(int typeNumber, this.errorCorrectLevel)
  : this.typeNumber = typeNumber,
    moduleCount = typeNumber * 4 + 17,
  _modules = new List&lt;List&lt;bool&gt;&gt;() {
    requireArgument(typeNumber &gt; 0 &amp;&amp; typeNumber &lt; 11, 'typeNumber');
    requireArgument(QrErrorCorrectLevel.levels.indexOf(errorCorrectLevel) &gt;= 0,
        'errorCorrectLevel');

    for (var row = 0; row &lt; moduleCount; row++) {
      _modules.add(new List&lt;bool&gt;(moduleCount));
    }

    _dataCache = null;
    _dataList = [];
  }

  bool isDark(int row, int col) {
    if (row &lt; 0 || moduleCount &lt;= row || col &lt; 0 || moduleCount &lt;= col) {
      throw '$row , $col';
    }
    return _modules[row][col];
  }

  void addData(String data) {
    var newData = new QrByte(data);
    _dataList.add(newData);
    _dataCache = null;
  }

  void make() {
    _makeImpl(false, _getBestMaskPattern());
  }

  void _setupPositionProbePattern(int row, int col) {

    for (var r = -1; r &lt;= 7; r++) {

      if (row + r &lt;= -1 || moduleCount &lt;= row + r) continue;

      for (var c = -1; c &lt;= 7; c++) {

        if (col + c &lt;= -1 || moduleCount &lt;= col + c) continue;

        if ((0 &lt;= r &amp;&amp; r &lt;= 6 &amp;&amp; (c == 0 || c == 6)) ||
            (0 &lt;= c &amp;&amp; c &lt;= 6 &amp;&amp; (r == 0 || r == 6)) ||
            (2 &lt;= r &amp;&amp; r &lt;= 4 &amp;&amp; 2 &lt;= c &amp;&amp; c &lt;= 4)) {
          _modules[row + r][col + c] = true;
        } else {
          _modules[row + r][col + c] = false;
        }
      }
    }
  }

  int _getBestMaskPattern() {

    var minLostPoint = 0;
    var pattern = 0;

    for (var i = 0; i &lt; 8; i++) {

      _makeImpl(true, i);

      var lostPoint = QrUtil.getLostPoint(this);

      if (i == 0 || minLostPoint &gt; lostPoint) {
        minLostPoint = lostPoint;
        pattern = i;
      }
    }

    return pattern;
  }

  void _setupTimingPattern() {

    for (var r = 8; r &lt; moduleCount - 8; r++) {
      if (_modules[r][6] != null) {
        continue;
      }
      _modules[r][6] = (r % 2 == 0);
    }

    for (var c = 8; c &lt; moduleCount - 8; c++) {
      if (_modules[6][c] != null) {
        continue;
      }
      _modules[6][c] = (c % 2 == 0);
    }
  }

  void _setupPositionAdjustPattern() {

    var pos = QrUtil.getPatternPosition(typeNumber);

    for (var i = 0; i &lt; pos.length; i++) {

      for (var j = 0; j &lt; pos.length; j++) {

        var row = pos[i];
        var col = pos[j];

        if (_modules[row][col] != null) {
          continue;
        }

        for (var r = -2; r &lt;= 2; r++) {

          for (var c = -2; c &lt;= 2; c++) {

            if (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 &amp;&amp; c == 0)) {
              _modules[row + r][col + c] = true;
            } else {
              _modules[row + r][col + c] = false;
            }
          }
        }
      }
    }
  }

  void _setupTypeNumber(bool test) {

    var bits = QrUtil.getBCHTypeNumber(this.typeNumber);

    for (int i = 0; i &lt; 18; i++) {
      final bool mod = (!test &amp;&amp; ((bits &gt;&gt; i) &amp; 1) == 1);
      _modules[i ~/ 3][i % 3 + moduleCount - 8 - 3] = mod;
    }

    for (int i = 0; i &lt; 18; i++) {
      final bool mod = (!test &amp;&amp; ((bits &gt;&gt; i) &amp; 1) == 1);
      _modules[i % 3 + moduleCount - 8 - 3][i ~/ 3] = mod;
    }
  }

  void _setupTypeInfo(bool test, maskPattern) {

    var data = (this.errorCorrectLevel &lt;&lt; 3) | maskPattern;
    var bits = QrUtil.getBCHTypeInfo(data);

    var i, mod;

    // vertical
    for (i = 0; i &lt; 15; i++) {

      mod = (!test &amp;&amp; ((bits &gt;&gt; i) &amp; 1) == 1);

      if (i &lt; 6) {
        _modules[i][8] = mod;
      } else if (i &lt; 8) {
        _modules[i + 1][8] = mod;
      } else {
        _modules[moduleCount - 15 + i][8] = mod;
      }
    }

    // horizontal
    for (i = 0; i &lt; 15; i++) {

      mod = (!test &amp;&amp; ((bits &gt;&gt; i) &amp; 1) == 1);

      if (i &lt; 8) {
        _modules[8][moduleCount - i - 1] = mod;
      } else if (i &lt; 9) {
        _modules[8][15 - i - 1 + 1] = mod;
      } else {
        _modules[8][15 - i - 1] = mod;
      }
    }

    // fixed module
    _modules[moduleCount - 8][8] = (!test);

  }

  void _mapData(List&lt;int&gt; data, maskPattern) {
    var inc = -1;
    var row = moduleCount - 1;
    var bitIndex = 7;
    var byteIndex = 0;

    for (var col = moduleCount - 1; col &gt; 0; col -= 2) {

      if (col == 6) col--;

      while (true) {

        for (var c = 0; c &lt; 2; c++) {

          if (_modules[row][col - c] == null) {

            var dark = false;

            if (byteIndex &lt; data.length) {
              dark = (((data[byteIndex] &gt;&gt; bitIndex) &amp; 1) == 1);
            }

            var mask = QrUtil.getMask(maskPattern, row, col - c);

            if (mask) {
              dark = !dark;
            }

            _modules[row][col - c] = dark;
            bitIndex--;

            if (bitIndex == -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }

        row += inc;

        if (row &lt; 0 || moduleCount &lt;= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }

  }

  void _makeImpl(bool test, int maskPattern) {

    _setupPositionProbePattern(0, 0);
    _setupPositionProbePattern(moduleCount - 7, 0);
    _setupPositionProbePattern(0, moduleCount - 7);
    _setupPositionAdjustPattern();
    _setupTimingPattern();
    _setupTypeInfo(test, maskPattern);

    if (typeNumber &gt;= 7) {
      _setupTypeNumber(test);
    }

    if (_dataCache == null) {
      _dataCache = _createData(typeNumber, errorCorrectLevel, _dataList);
    }

    _mapData(_dataCache, maskPattern);
  }

  static List&lt;int&gt; _createData(int typeNumber, int errorCorrectLevel, List&lt;QrByte&gt; dataList) {

    var rsBlocks = QrRsBlock.getRSBlocks(typeNumber, errorCorrectLevel);

    final buffer = new QrBitBuffer();

    for (int i = 0; i &lt; dataList.length; i++) {
      var data = dataList[i];
      buffer.put(data.mode, 4);
      buffer.put(data.length, QrUtil.getLengthInBits(data.mode, typeNumber));
      data.write(buffer);
    }

    // HUH?
    // ç≈ëÂÉfÅ[É^êîÇåvéZ
    var totalDataCount = 0;
    for (int i = 0; i &lt; rsBlocks.length; i++) {
      totalDataCount += rsBlocks[i].dataCount;
    }

    final totalByteCount = totalDataCount * 8;
    if (buffer.length &gt; totalByteCount) {
      throw new QrInputTooLongException(buffer.length, totalByteCount);
    }

    // HUH?
    // èIí[ÉRÅ[Éh
    if (buffer.length + 4 &lt;= totalByteCount) {
      buffer.put(0, 4);
    }

    // padding
    while (buffer.length % 8 != 0) {
      buffer.putBit(false);
    }

    // padding
    while (true) {

      if (buffer.length &gt;= totalDataCount * 8) {
        break;
      }
      buffer.put(_PAD0, 8);

      if (buffer.length &gt;= totalDataCount * 8) {
        break;
      }
      buffer.put(_PAD1, 8);
    }

    return _createBytes(buffer, rsBlocks);
  }

  static List&lt;int&gt; _createBytes(QrBitBuffer buffer, rsBlocks) {

    var offset = 0;

    var maxDcCount = 0;
    var maxEcCount = 0;

    var dcdata = new List&lt;List&gt;(rsBlocks.length);

    var ecdata = new List&lt;List&gt;(rsBlocks.length);

    for (int r = 0; r &lt; rsBlocks.length; r++) {

      var dcCount = rsBlocks[r].dataCount;
      var ecCount = rsBlocks[r].totalCount - dcCount;

      maxDcCount = math.max(maxDcCount, dcCount);
      maxEcCount = math.max(maxEcCount, ecCount);

      dcdata[r] = QrMath.getZeroedList(dcCount);

      for (int i = 0; i &lt; dcdata[r].length; i++) {
        dcdata[r][i] = 0xff &amp; buffer.getByte(i + offset);
      }
      offset += dcCount;

      var rsPoly = QrUtil.getErrorCorrectPolynomial(ecCount);
      var rawPoly = new QrPolynomial(dcdata[r], rsPoly.length - 1);

      var modPoly = rawPoly.mod(rsPoly);
      ecdata[r] = QrMath.getZeroedList(rsPoly.length - 1);

      for (int i = 0; i &lt; ecdata[r].length; i++) {
        var modIndex = i + modPoly.length - ecdata[r].length;
        ecdata[r][i] = (modIndex &gt;= 0) ? modPoly[modIndex] : 0;
      }

    }

    var totalCodeCount = 0;
    for (int i = 0; i &lt; rsBlocks.length; i++) {
      totalCodeCount += rsBlocks[i].totalCount;
    }

    var data = [];

    for (int i = 0; i &lt; maxDcCount; i++) {
      for (int r = 0; r &lt; rsBlocks.length; r++) {
        if (i &lt; dcdata[r].length) {
          data.add(dcdata[r][i]);
        }
      }
    }

    for (int i = 0; i &lt; maxEcCount; i++) {
      for (int r = 0; r &lt; rsBlocks.length; r++) {
        if (i &lt; ecdata[r].length) {
          data.add(ecdata[r][i]);
        }
      }
    }

    return data;
  }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="QrCode">
<button class="show-code">Code</button>
new <strong>QrCode</strong>(int typeNumber, errorCorrectLevel) <a class="anchor-link" href="#QrCode"
              title="Permalink to QrCode.QrCode">#</a></h4>
<div class="doc">
<pre class="source">
QrCode(int typeNumber, this.errorCorrectLevel)
: this.typeNumber = typeNumber,
  moduleCount = typeNumber * 4 + 17,
_modules = new List&lt;List&lt;bool&gt;&gt;() {
  requireArgument(typeNumber &gt; 0 &amp;&amp; typeNumber &lt; 11, 'typeNumber');
  requireArgument(QrErrorCorrectLevel.levels.indexOf(errorCorrectLevel) &gt;= 0,
      'errorCorrectLevel');

  for (var row = 0; row &lt; moduleCount; row++) {
    _modules.add(new List&lt;bool&gt;(moduleCount));
  }

  _dataCache = null;
  _dataList = [];
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="errorCorrectLevel">
<button class="show-code">Code</button>
final         <strong>errorCorrectLevel</strong> <a class="anchor-link"
            href="#errorCorrectLevel"
            title="Permalink to QrCode.errorCorrectLevel">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final errorCorrectLevel;
</pre>
</div>
</div>
<div class="field"><h4 id="moduleCount">
<button class="show-code">Code</button>
final int         <strong>moduleCount</strong> <a class="anchor-link"
            href="#moduleCount"
            title="Permalink to QrCode.moduleCount">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final int moduleCount;
</pre>
</div>
</div>
<div class="field inherited"><h4 id="runtimeType">
<button class="show-code">Code</button>
final Type         <strong>runtimeType</strong> <a class="anchor-link"
            href="#runtimeType"
            title="Permalink to QrCode.runtimeType">#</a>
        </h4>
        <div class="inherited-from">inherited from Object </div><div class="doc">
<p>A representation of the runtime type of the object.</p>
<pre class="source">
external Type get runtimeType;
</pre>
</div>
</div>
<div class="field"><h4 id="typeNumber">
<button class="show-code">Code</button>
final         <strong>typeNumber</strong> <a class="anchor-link"
            href="#typeNumber"
            title="Permalink to QrCode.typeNumber">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final typeNumber;
</pre>
</div>
</div>
</div>
<div>
<h3>Operators</h3>
<div class="method inherited"><h4 id="==">
<button class="show-code">Code</button>
bool <strong>operator ==</strong>(other) <a class="anchor-link" href="#=="
              title="Permalink to QrCode.operator ==">#</a></h4>
<div class="inherited-from">inherited from Object </div><div class="doc">
<p>The equality operator.</p>
<p>The default behavior for all <code>Object</code>s is to return true if and
only if <code>this</code> and 
<span class="param">other</span> are the same object.</p>
<p>If a subclass overrides the equality operator it should override
the <code>hashCode</code> method as well to maintain consistency.</p>
<pre class="source">
bool operator ==(other) =&gt; identical(this, other);
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="addData">
<button class="show-code">Code</button>
void <strong>addData</strong>(String data) <a class="anchor-link" href="#addData"
              title="Permalink to QrCode.addData">#</a></h4>
<div class="doc">
<pre class="source">
void addData(String data) {
  var newData = new QrByte(data);
  _dataList.add(newData);
  _dataCache = null;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="hashCode">
<button class="show-code">Code</button>
int <strong>hashCode</strong>() <a class="anchor-link" href="#hashCode"
              title="Permalink to QrCode.hashCode">#</a></h4>
<div class="inherited-from">inherited from Object </div><div class="doc">
<p>Get a hash code for this object.</p>
<p>All objects have hash codes. Hash codes are guaranteed to be the
same for objects that are equal when compared using the equality
operator <code>==</code>. Other than that there are no guarantees about
the hash codes. They will not be consistent between runs and
there are no distribution guarantees.</p>
<p>If a subclass overrides <code>hashCode</code> it should override the
equality operator as well to maintain consistency.</p>
<pre class="source">
external int hashCode();
</pre>
</div>
</div>
<div class="method"><h4 id="isDark">
<button class="show-code">Code</button>
bool <strong>isDark</strong>(int row, int col) <a class="anchor-link" href="#isDark"
              title="Permalink to QrCode.isDark">#</a></h4>
<div class="doc">
<pre class="source">
bool isDark(int row, int col) {
  if (row &lt; 0 || moduleCount &lt;= row || col &lt; 0 || moduleCount &lt;= col) {
    throw '$row , $col';
  }
  return _modules[row][col];
}
</pre>
</div>
</div>
<div class="method"><h4 id="make">
<button class="show-code">Code</button>
void <strong>make</strong>() <a class="anchor-link" href="#make"
              title="Permalink to QrCode.make">#</a></h4>
<div class="doc">
<pre class="source">
void make() {
  _makeImpl(false, _getBestMaskPattern());
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="noSuchMethod">
<button class="show-code">Code</button>
<strong>noSuchMethod</strong>(String name, List args) <a class="anchor-link" href="#noSuchMethod"
              title="Permalink to QrCode.noSuchMethod">#</a></h4>
<div class="inherited-from">inherited from Object </div><div class="doc">
<p><code>noSuchMethod</code> is invoked when users invoke a non-existant method
on an object. The name of the method and the arguments of the
invocation are passed to <code>noSuchMethod</code>. If <code>noSuchMethod</code>
returns a value, that value becomes the result of the original
invocation.</p>
<p>The default behavior of <code>noSuchMethod</code> is to throw a
<code>noSuchMethodError</code>.</p>
<pre class="source">
external Dynamic noSuchMethod(String name, List args);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="Object">
<button class="show-code">Code</button>
const <strong>Object</strong>() <a class="anchor-link" href="#Object"
              title="Permalink to QrCode.Object">#</a></h4>
<div class="inherited-from">inherited from Object </div><div class="doc">
<p>Creates a new <code>Object</code> instance.</p>
<p><code>Object</code> instances have no meaningful state, and are only useful
through their identity. An <code>Object</code> instance is equal to itself
only.</p>
<pre class="source">
const Object();
</pre>
</div>
</div>
<div class="method"><h4 id="QrCode">
<button class="show-code">Code</button>
new <strong>QrCode</strong>(int typeNumber, errorCorrectLevel) <a class="anchor-link" href="#QrCode"
              title="Permalink to QrCode.QrCode">#</a></h4>
<div class="doc">
<pre class="source">
QrCode(int typeNumber, this.errorCorrectLevel)
: this.typeNumber = typeNumber,
  moduleCount = typeNumber * 4 + 17,
_modules = new List&lt;List&lt;bool&gt;&gt;() {
  requireArgument(typeNumber &gt; 0 &amp;&amp; typeNumber &lt; 11, 'typeNumber');
  requireArgument(QrErrorCorrectLevel.levels.indexOf(errorCorrectLevel) &gt;= 0,
      'errorCorrectLevel');

  for (var row = 0; row &lt; moduleCount; row++) {
    _modules.add(new List&lt;bool&gt;(moduleCount));
  }

  _dataCache = null;
  _dataList = [];
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="toString">
<button class="show-code">Code</button>
String <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to QrCode.toString">#</a></h4>
<div class="inherited-from">inherited from Object </div><div class="doc">
<p>Returns a string representation of this object.</p>
<pre class="source">
external String toString();
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
