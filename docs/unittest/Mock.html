        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Mock Class / unittest Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="unittest" data-type="Mock">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../unittest.html">unittest</a> &rsaquo; <a href="../unittest/Mock.html">Mock</a></div>
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Mock</strong>
          Class
        </h2>
        
<div class="doc">
<p><a class="crossref" href="../unittest/Mock.html#new:Mock">Mock</a> is the base class for all mocked objects, with
support for basic mocking.</p>
<p>To create a mock objects for some class T, create a new class using:</p>
<pre><code>class MockT extends Mock implements T {};
</code></pre>
<p>Then specify the behavior of the Mock for different methods using
<a class="crossref" href="../unittest/Mock.html#when">when</a> (to select the method and parameters) and <code>thenReturn</code>,
<code>alwaysReturn</code>, <code>thenThrow</code>, <code>alwaysThrow</code>, <code>thenCall</code> or <code>alwaysCall</code>.
<code>thenReturn</code>, <code>thenThrow</code> and <code>thenCall</code> are one-shot so you would
typically call these more than once to specify a sequence of actions;
this can be done with chained calls, e.g.:</p>
<pre><code> m.when(callsTo('foo')).
     thenReturn(0).thenReturn(1).thenReturn(2);
</code></pre>
<p><code>thenCall</code> and <code>alwaysCall</code> allow you to proxy mocked methods, chaining
to some other implementation. This provides a way to implement 'spies'.</p>
<p>You can then use the mock object. Once you are done, to verify the
behavior, use <a class="crossref" href="../unittest/Mock.html#getLogs">getLogs</a> to extract a relevant subset of method call
logs and apply <code>Matchers</code> to these through calling <code>verify</code>.</p>
<p>A Mock can be given a name when constructed. In this case instead of
keeping its own log, it uses a shared log. This can be useful to get an
audit trail of interleaved behavior. It is the responsibility of the user
to ensure that mock names, if used, are unique.</p>
<p>Limitations:
- only positional parameters are supported (up to 10);
- to mock getters you will need to include parentheses in the call</p>
<pre><code>  (e.g. m.length() will work but not m.length).
</code></pre>
<p>Here is a simple example:</p>
<pre><code>class MockList extends Mock implements List {};
</code></pre>
<pre><code>List m = new MockList();
m.when(callsTo('add', anything)).alwaysReturn(0);
</code></pre>
<pre><code>m.add('foo');
m.add('bar');
</code></pre>
<pre><code>getLogs(m, callsTo('add', anything)).verify(happenedExactly(2));
getLogs(m, callsTo('add', 'foo')).verify(happenedOnce);
getLogs(m, callsTo('add', 'isNull)).verify(neverHappened);
</code></pre>
<p>Note that we don't need to provide argument matchers for all arguments,
but we do need to provide arguments for all matchers. So this is allowed:</p>
<pre><code>m.when(callsTo('add')).alwaysReturn(0);
m.add(1, 2);
</code></pre>
<p>But this is not allowed and will throw an exception:</p>
<pre><code>m.when(callsTo('add', anything, anything)).alwaysReturn(0);
m.add(1);
</code></pre>
<p>Here is a way to implement a 'spy', which is where we log the call
but then hand it off to some other function, which is the same
method in a real instance of the class being mocked:</p>
<pre><code>class Foo {
  bar(a, b, c) =&gt; a + b + c;
}
</code></pre>
<pre><code>class MockFoo extends Mock implements Foo {
  Foo real;
  MockFoo() {
    real = new Foo();
    this.when(callsTo('bar')).alwaysCall(real.bar);
  }
}
</code></pre>
</div>
<h3>Constructors</h3>
<div class="method"><h4 id="Mock">
<span class="show-code">Code</span>
new <strong>Mock</strong>.custom([<a href="../core/String.html">String</a> name, <a href="../unittest/LogEntryList.html">LogEntryList</a> log, throwIfNoBehavior = false, enableLogging = true]) <a class="anchor-link" href="#Mock"
              title="Permalink to Mock.Mock">#</a></h4>
<div class="doc">
<p>This constructor makes a mock that has a 
<span class="param">name</span> and possibly uses
a shared 
<span class="param">log</span>. If 
<span class="param">throwIfNoBehavior</span> is true, any calls to methods
that have no defined behaviors will throw an exception; otherwise they
will be allowed and logged (but will not do anything).
If 
<span class="param">enableLogging</span> is false, no logging will be done initially (whether
or not a 
<span class="param">log</span> is supplied), but <a class="crossref" href="../unittest/Mock.html#logging">logging</a> can be set to true later.</p>
<pre class="source">
Mock.custom([this.name,
             this.log,
             throwIfNoBehavior = false,
             enableLogging = true]) : _throwIfNoBehavior = throwIfNoBehavior {
  if (log != null &amp;&amp; name == null) {
    throw new Exception("Mocks with shared logs must have a name.");
  }
  logging = enableLogging;
  _behaviors = new Map&lt;String,Behavior&gt;();
}
</pre>
</div>
</div>
<div class="method"><h4 id="Mock">
<span class="show-code">Code</span>
new <strong>Mock</strong>() <a class="anchor-link" href="#Mock"
              title="Permalink to Mock.Mock">#</a></h4>
<div class="doc">
<p>Default constructor. Unknown method calls are allowed and logged,
the mock has no name, and has its own log.</p>
<pre class="source">
Mock() : _throwIfNoBehavior = false, log = null, name = null {
  logging = true;
  _behaviors = new Map&lt;String,Behavior&gt;();
}
</pre>
</div>
</div>
<h3>Methods</h3>
<div class="method"><h4 id="getLogs">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>getLogs</strong>([<a href="../unittest/CallMatcher.html">CallMatcher</a> logFilter, <a href="../unittest/Matcher.html">Matcher</a> actionMatcher, <a href="../core/bool.html">bool</a> destructive = false]) <a class="anchor-link" href="#getLogs"
              title="Permalink to Mock.getLogs">#</a></h4>
<div class="doc">
<p><a class="crossref" href="../unittest/Mock.html#getLogs">getLogs</a> extracts all calls from the call log that match the
[logFilter] [CallMatcher], and returns the matching list of
<a class="crossref" href="../unittest/LogEntry.html">LogEntry</a>s. If 
<span class="param">destructive</span> is false (the default) the matching
calls are left in the log, else they are removed. Removal allows
us to verify a set of interactions and then verify that there are
no other interactions left. 
<span class="param">actionMatcher</span> can be used to further
restrict the returned logs based on the action the mock performed.</p>
<p>Typical usage:</p>
<pre><code>getLogs(callsTo(...)).verify(...);
</code></pre>
<pre class="source">
LogEntryList getLogs([CallMatcher logFilter,
                      Matcher actionMatcher,
                      bool destructive = false]) {
  if (log == null) {
    // This means we created the mock with logging off and have never turned
    // it on, so it doesn't make sense to get logs from such a mock.
    throw new
        Exception("Can't retrieve logs when logging was never enabled.");
  } else {
    return log.getMatches(name, logFilter, actionMatcher, destructive);
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="logging">
<span class="show-code">Code</span>
<a href="../core/bool.html">bool</a> <strong>get logging</strong>() <a class="anchor-link" href="#logging"
              title="Permalink to Mock.get logging">#</a></h4>
<div class="doc">

<pre class="source">
bool get logging() =&gt; _logging;
</pre>
</div>
</div>
<div class="method"><h4 id="logging">
<span class="show-code">Code</span>
<a href="../core/bool.html">bool</a> <strong>set logging</strong>(<a href="../core/bool.html">bool</a> value) <a class="anchor-link" href="#logging"
              title="Permalink to Mock.set logging">#</a></h4>
<div class="doc">

<pre class="source">
bool set logging(bool value) {
  if (value &amp;&amp; log == null) {
    log = new LogEntryList();
  }
  _logging = value;
}
</pre>
</div>
</div>
<div class="method"><h4 id="noSuchMethod">
<span class="show-code">Code</span>
<strong>noSuchMethod</strong>(<a href="../core/String.html">String</a> method, <a href="../core/List.html">List</a> args) <a class="anchor-link" href="#noSuchMethod"
              title="Permalink to Mock.noSuchMethod">#</a></h4>
<div class="doc">
<p>This is the handler for method calls. We loo through the list
of <a class="crossref" href="../unittest/Behavior.html">Behavior</a>s, and find the first match that still has return
values available, and then do the action specified by that
return value. If we find no <a class="crossref" href="../unittest/Behavior.html">Behavior</a> to apply an exception is
thrown.</p>
<pre class="source">
noSuchMethod(String method, List args) {
  if (method.startsWith('get:')) {
    method = 'get ${method.substring(4)}';
  }
  bool matchedMethodName = false;
  for (String k in _behaviors.getKeys()) {
    Behavior b = _behaviors[k];
    if (b.matcher.nameFilter.matches(method)) {
      matchedMethodName = true;
    }
    if (b.matches(method, args)) {
      List actions = b.actions;
      if (actions == null || actions.length == 0) {
        continue; // No return values left in this Behavior.
      }
      // Get the first response.
      Responder response = actions[0];
      // If it is exhausted, remove it from the list.
      // Note that for endlessly repeating values, we started the count at
      // 0, so we get a potentially useful value here, which is the
      // (negation of) the number of times we returned the value.
      if (--response.count == 0) {
        actions.removeRange(0, 1);
      }
      // Do the response.
      _Action action = response.action;
      var value = response.value;
      if (action == _Action.RETURN) {
        if (_logging) {
          log.add(new LogEntry(name, method, args, action, value));
        }
        return value;
      } else if (action == _Action.THROW) {
        if (_logging) {
          log.add(new LogEntry(name, method, args, action, value));
        }
        throw value;
      } else if (action == _Action.PROXY) {
        var rtn;
        switch (args.length) {
          case 0:
            rtn = value();
            break;
          case 1:
            rtn = value(args[0]);
            break;
          case 2:
            rtn = value(args[0], args[1]);
            break;
          case 3:
            rtn = value(args[0], args[1], args[2]);
            break;
          case 4:
            rtn = value(args[0], args[1], args[2], args[3]);
            break;
          case 5:
            rtn = value(args[0], args[1], args[2], args[3], args[4]);
            break;
          case 6:
            rtn = value(args[0], args[1], args[2], args[3],
                args[4], args[5]);
            break;
          case 7:
            rtn = value(args[0], args[1], args[2], args[3],
                args[4], args[5], args[6]);
            break;
          case 8:
            rtn = value(args[0], args[1], args[2], args[3],
                args[4], args[5], args[6], args[7]);
            break;
          case 9:
            rtn = value(args[0], args[1], args[2], args[3],
                args[4], args[5], args[6], args[7], args[8]);
            break;
          case 9:
            rtn = value(args[0], args[1], args[2], args[3],
                args[4], args[5], args[6], args[7], args[8], args[9]);
            break;
          default:
            throw new Exception(
                "Cannot proxy calls with more than 10 parameters.");
        }
        if (_logging) {
          log.add(new LogEntry(name, method, args, action, rtn));
        }
        return rtn;
      }
    }
  }
  if (matchedMethodName) {
    // User did specify behavior for this method, but all the
    // actions are exhausted. This is considered an error.
    throw new Exception('No more actions for method '
        '${_qualifiedName(name, method)}.');
  } else if (_throwIfNoBehavior) {
    throw new Exception('No behavior specified for method '
        '${_qualifiedName(name, method)}.');
  }
  // Otherwise user hasn't specified behavior for this method; we don't throw
  // so we can underspecify.
  if (_logging) {
    log.add(new LogEntry(name, method, args, _Action.IGNORE));
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="verifyZeroInteractions">
<span class="show-code">Code</span>
<a href="../core/bool.html">bool</a> <strong>verifyZeroInteractions</strong>() <a class="anchor-link" href="#verifyZeroInteractions"
              title="Permalink to Mock.verifyZeroInteractions">#</a></h4>
<div class="doc">
<p><a class="crossref" href="../unittest/Mock.html#verifyZeroInteractions">verifyZeroInteractions</a> returns true if no calls were made</p>
<pre class="source">
bool verifyZeroInteractions() {
  if (log == null) {
    // This means we created the mock with logging off and have never turned
    // it on, so it doesn't make sense to verify behavior on such a mock.
    throw new
        Exception("Can't verify behavior when logging was never enabled.");
  }
  return log.logs.length == 0;
}
</pre>
</div>
</div>
<div class="method"><h4 id="when">
<span class="show-code">Code</span>
<a href="../unittest/Behavior.html">Behavior</a> <strong>when</strong>(<a href="../unittest/CallMatcher.html">CallMatcher</a> logFilter) <a class="anchor-link" href="#when"
              title="Permalink to Mock.when">#</a></h4>
<div class="doc">
<p><a class="crossref" href="../unittest/Mock.html#when">when</a> is used to create a new or extend an existing <a class="crossref" href="../unittest/Behavior.html">Behavior</a>.
A [CallMatcher] [filter] must be supplied, and the <a class="crossref" href="../unittest/Behavior.html">Behavior</a>s for
that signature are returned (being created first if needed).</p>
<p>Typical use case:</p>
<pre><code>mock.when(callsTo(...)).alwaysReturn(...);
</code></pre>
<pre class="source">
Behavior when(CallMatcher logFilter) {
  String key = logFilter.toString();
  if (!_behaviors.containsKey(key)) {
    Behavior b = new Behavior(logFilter);
    _behaviors[key] = b;
    return b;
  } else {
    return _behaviors[key];
  }
}
</pre>
</div>
</div>
<h3>Fields</h3>
<div class="field"><h4 id="log">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a>         <strong>log</strong> <a class="anchor-link"
            href="#log"
            title="Permalink to Mock.log">#</a>
        </h4>
        <div class="doc">
<p>The <a class="crossref" href="../unittest/Mock.html#log">log</a> of calls made. Only used if <a class="crossref" href="../unittest/Mock.html#name">name</a> is null.</p>
<pre class="source">
LogEntryList log;
</pre>
</div>
</div>
<div class="field"><h4 id="name">
<span class="show-code">Code</span>
final <a href="../core/String.html">String</a>         <strong>name</strong> <a class="anchor-link"
            href="#name"
            title="Permalink to Mock.name">#</a>
        </h4>
        <div class="doc">
<p>The mock name. Needed if the log is shared; optional otherwise.</p>
<pre class="source">
final String name;
</pre>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
