        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>LogEntryList Class / unittest Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="unittest" data-type="LogEntryList">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../unittest.html">unittest</a> &rsaquo; <a href="../unittest/LogEntryList.html">LogEntryList</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>LogEntryList</strong>
          Class
        </h2>
        
<div class="doc">
<p>We do verification on a list of <a class="crossref" href="../unittest/LogEntry.html">LogEntry</a>s. To allow chaining
of calls to verify, we encapsulate such a list in the <a class="crossref" href="../unittest/LogEntryList.html#LogEntryList">LogEntryList</a>
class.</p>
</div>
<h3>Constructors</h3>
<div class="method"><h4 id="LogEntryList">
<span class="show-code">Code</span>
new <strong>LogEntryList</strong>([String filter]) <a class="anchor-link" href="#LogEntryList"
              title="Permalink to LogEntryList.LogEntryList">#</a></h4>
<div class="doc">

<pre class="source">
LogEntryList([this.filter]) {
  logs = new List&lt;LogEntry&gt;();
}
</pre>
</div>
</div>
<h3>Methods</h3>
<div class="method"><h4 id="add">
<span class="show-code">Code</span>
<strong>add</strong>(<a href="../unittest/LogEntry.html">LogEntry</a> entry) <a class="anchor-link" href="#add"
              title="Permalink to LogEntryList.add">#</a></h4>
<div class="doc">
<p>Add a <a class="crossref" href="../unittest/LogEntry.html">LogEntry</a> to the log.</p>
<pre class="source">
add(LogEntry entry) =&gt; logs.add(entry);
</pre>
</div>
</div>
<div class="method"><h4 id="after">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>after</strong>(Date when, [bool inPlace = false]) <a class="anchor-link" href="#after"
              title="Permalink to LogEntryList.after">#</a></h4>
<div class="doc">
<p>Returns log events that happened after 
<span class="param">when</span>. If 
<span class="param">inPlace</span>
is true, then it returns this LogEntryList after removing
the entries that happened up to 
<span class="param">when</span>; otherwise a new
list is created.</p>
<pre class="source">
LogEntryList after(Date when, [bool inPlace = false]) =&gt;
    _tail((e) =&gt; e.time &gt; when, inPlace, 'after $when', logs.length);
</pre>
</div>
</div>
<div class="method"><h4 id="afterEntry">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>afterEntry</strong>(<a href="../unittest/LogEntry.html">LogEntry</a> logEntry, [bool inPlace = false]) <a class="anchor-link" href="#afterEntry"
              title="Permalink to LogEntryList.afterEntry">#</a></h4>
<div class="doc">
<p>Returns log events that happened after 
<span class="param">logEntry</span>'s time.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after
removing the entries that happened up to <code>when</code>; otherwise a new
list is created. If 
<span class="param">logEntry</span> is null the current time is used.</p>
<pre class="source">
LogEntryList afterEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
    after(logEntry == null ? new Date.now() : logEntry.time);
</pre>
</div>
</div>
<div class="method"><h4 id="afterFirst">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>afterFirst</strong>(<a href="../unittest/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#afterFirst"
              title="Permalink to LogEntryList.afterFirst">#</a></h4>
<div class="doc">
<p>Returns log events that happened after the first event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened earlier; otherwise a new list is created.</p>
<pre class="source">
LogEntryList afterFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
    afterEntry(segment.first, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="afterLast">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>afterLast</strong>(<a href="../unittest/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#afterLast"
              title="Permalink to LogEntryList.afterLast">#</a></h4>
<div class="doc">
<p>Returns log events that happened after the last event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened earlier; otherwise a new list is created.</p>
<pre class="source">
LogEntryList afterLast(LogEntryList segment, [bool inPlace = false]) =&gt;
    afterEntry(segment.last, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="before">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>before</strong>(Date when, [bool inPlace = false]) <a class="anchor-link" href="#before"
              title="Permalink to LogEntryList.before">#</a></h4>
<div class="doc">
<p>Returns log events that happened before 
<span class="param">when</span>. If 
<span class="param">inPlace</span>
is true, then it returns this LogEntryList after removing
the entries that happened from 
<span class="param">when</span> onwards; otherwise a new
list is created.</p>
<pre class="source">
LogEntryList before(Date when, [bool inPlace = false]) =&gt;
    _head((e) =&gt; e.time &gt;= when, inPlace, 'before $when', logs.length);
</pre>
</div>
</div>
<div class="method"><h4 id="beforeEntry">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>beforeEntry</strong>(<a href="../unittest/LogEntry.html">LogEntry</a> logEntry, [bool inPlace = false]) <a class="anchor-link" href="#beforeEntry"
              title="Permalink to LogEntryList.beforeEntry">#</a></h4>
<div class="doc">
<p>Returns log events that happened before 
<span class="param">logEntry</span>'s time. If

<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened from <code>when</code> onwards; otherwise a new
list is created. If 
<span class="param">logEntry</span> is null the epoch time is used.</p>
<pre class="source">
LogEntryList beforeEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
    before(logEntry == null ?
        new Date.fromMillisecondsSinceEpoch(0) : logEntry.time);
</pre>
</div>
</div>
<div class="method"><h4 id="beforeFirst">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>beforeFirst</strong>(<a href="../unittest/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#beforeFirst"
              title="Permalink to LogEntryList.beforeFirst">#</a></h4>
<div class="doc">
<p>Returns log events that happened before the first event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened later; otherwise a new list is created.</p>
<pre class="source">
LogEntryList beforeFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
    beforeEntry(segment.first, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="beforeLast">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>beforeLast</strong>(<a href="../unittest/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#beforeLast"
              title="Permalink to LogEntryList.beforeLast">#</a></h4>
<div class="doc">
<p>Returns log events that happened before the last event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened later; otherwise a new list is created.</p>
<pre class="source">
LogEntryList beforeLast(LogEntryList segment, [bool inPlace = false]) =&gt;
    beforeEntry(segment.last, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="findLogEntry">
<span class="show-code">Code</span>
int <strong>findLogEntry</strong>(logFilter, [int start = 0, int failureReturnValue = -1, skip = 1]) <a class="anchor-link" href="#findLogEntry"
              title="Permalink to LogEntryList.findLogEntry">#</a></h4>
<div class="doc">
<p> Find the first log entry that satisfies 
<span class="param">logFilter</span> and
 return its position. A search 
<span class="param">start</span> position can be provided
 to allow for repeated searches. 
<span class="param">logFilter</span> can be a <a class="crossref" href="../unittest/CallMatcher.html">CallMatcher</a>,
 or a predicate function that takes a <a class="crossref" href="../unittest/LogEntry.html">LogEntry</a> argument and returns
 a bool. If 
<span class="param">logFilter</span> is null, it will match any <a class="crossref" href="../unittest/LogEntry.html">LogEntry</a>.
 If no entry is found, then 
<span class="param">failureReturnValue</span> is returned.
 After each check the position is updated by 
<span class="param">skip</span>, so using
 
<span class="param">skip</span> of -1 allows backward searches, using a 
<span class="param">skip</span> of 2 can
 be used to check pairs of adjacent entries, and so on.</p>
<pre class="source">
int findLogEntry(logFilter, [int start = 0, int failureReturnValue = -1,
    skip = 1]) {
  logFilter = _makePredicate(logFilter);
  int pos = start;
  while (pos &gt;= 0 &amp;&amp; pos &lt; logs.length) {
    if (logFilter(logs[pos])) {
      return pos;
    }
    pos += skip;
  }
  return failureReturnValue;
}
</pre>
</div>
</div>
<div class="method"><h4 id="first">
<span class="show-code">Code</span>
<strong>get first</strong>() <a class="anchor-link" href="#first"
              title="Permalink to LogEntryList.get first">#</a></h4>
<div class="doc">
<p>Get the first entry, or null if no entries.</p>
<pre class="source">
get first =&gt; (logs == null || logs.length == 0) ? null : logs[0];
</pre>
</div>
</div>
<div class="method"><h4 id="following">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>following</strong>(<a href="../unittest/LogEntryList.html">LogEntryList</a> keys, [mockNameFilter = null, logFilter = null, int distance = 1, bool includeKeys = false]) <a class="anchor-link" href="#following"
              title="Permalink to LogEntryList.following">#</a></h4>
<div class="doc">
<p>Iterate through the LogEntryList looking for matches to the entries
in 
<span class="param">keys</span>; for each match found the closest 
<span class="param">distance</span> subsequent log
entries that match <code>mocknameFilter</code> and 
<span class="param">logFilter</span> will be included in
the result. If 
<span class="param">includeKeys</span> is true then the entries in 
<span class="param">keys</span> that
resulted in entries in the output list are themselves included in the
output list. If 
<span class="param">distance</span> is zero then all matches are included.
See <a class="crossref" href="../unittest/LogEntryList.html#preceding">preceding</a> for a usage example.</p>
<pre class="source">
LogEntryList following(LogEntryList keys,
                       [mockNameFilter = null,
                       logFilter = null,
                       int distance = 1,
                       bool includeKeys = false]) =&gt;
    _neighboring(false, keys, mockNameFilter, logFilter,
        distance, includeKeys);
</pre>
</div>
</div>
<div class="method"><h4 id="from">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>from</strong>(Date when, [bool inPlace = false]) <a class="anchor-link" href="#from"
              title="Permalink to LogEntryList.from">#</a></h4>
<div class="doc">
<p>Returns log events that happened from 
<span class="param">when</span> onwards. If

<span class="param">inPlace</span> is true, then it returns this LogEntryList after
removing the entries that happened before 
<span class="param">when</span>; otherwise
a new list is created.</p>
<pre class="source">
LogEntryList from(Date when, [bool inPlace = false]) =&gt;
    _tail((e) =&gt; e.time &gt;= when, inPlace, 'from $when', logs.length);
</pre>
</div>
</div>
<div class="method"><h4 id="fromEntry">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>fromEntry</strong>(<a href="../unittest/LogEntry.html">LogEntry</a> logEntry, [bool inPlace = false]) <a class="anchor-link" href="#fromEntry"
              title="Permalink to LogEntryList.fromEntry">#</a></h4>
<div class="doc">
<p>Returns log events that happened from 
<span class="param">logEntry</span>'s time onwards.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after
removing the entries that happened before <code>when</code>; otherwise
a new list is created. If 
<span class="param">logEntry</span> is null the current time is used.</p>
<pre class="source">
LogEntryList fromEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
    from(logEntry == null ? new Date.now() : logEntry.time);
</pre>
</div>
</div>
<div class="method"><h4 id="fromFirst">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>fromFirst</strong>(<a href="../unittest/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#fromFirst"
              title="Permalink to LogEntryList.fromFirst">#</a></h4>
<div class="doc">
<p>Returns log events that happened from the time of the first event in

<span class="param">segment</span> onwards. If 
<span class="param">inPlace</span> is true, then it returns this
LogEntryList after removing the earlier entries; otherwise a new list
is created.</p>
<pre class="source">
LogEntryList fromFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
    fromEntry(segment.first, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="fromLast">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>fromLast</strong>(<a href="../unittest/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#fromLast"
              title="Permalink to LogEntryList.fromLast">#</a></h4>
<div class="doc">
<p>Returns log events that happened from the time of the last event in

<span class="param">segment</span> onwards. If 
<span class="param">inPlace</span> is true, then it returns this
LogEntryList after removing the earlier entries; otherwise a new list
is created.</p>
<pre class="source">
LogEntryList fromLast(LogEntryList segment, [bool inPlace = false]) =&gt;
    fromEntry(segment.last, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="getMatches">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>getMatches</strong>([mockNameFilter, logFilter, <a href="../unittest/Matcher.html">Matcher</a> actionMatcher, bool destructive = false]) <a class="anchor-link" href="#getMatches"
              title="Permalink to LogEntryList.getMatches">#</a></h4>
<div class="doc">
<p>Create a new <a class="crossref" href="../unittest/LogEntryList.html#LogEntryList">LogEntryList</a> consisting of <a class="crossref" href="../unittest/LogEntry.html">LogEntry</a>s from
this list that match the specified 
<span class="param">mockNameFilter</span> and 
<span class="param">logFilter</span>.

<span class="param">mockNameFilter</span> can be null, a <code>String</code>, a predicate <code>Function</code>,
or a <a class="crossref" href="../unittest/Matcher.html">Matcher</a>. If 
<span class="param">mockNameFilter</span> is null, this is the same as
<a class="crossref" href="../unittest.html#anything">anything</a>.
If 
<span class="param">logFilter</span> is null, all entries in the log will be returned.
Otherwise 
<span class="param">logFilter</span> should be a <a class="crossref" href="../unittest/CallMatcher.html">CallMatcher</a> or  predicate function
that takes a <a class="crossref" href="../unittest/LogEntry.html">LogEntry</a> and returns a bool.
If 
<span class="param">destructive</span> is true, the log entries are removed from the
original list.</p>
<pre class="source">
LogEntryList getMatches([mockNameFilter,
                        logFilter,
                        Matcher actionMatcher,
                        bool destructive = false]) {
  if (mockNameFilter == null) {
    mockNameFilter = anything;
  } else {
    mockNameFilter = wrapMatcher(mockNameFilter);
  }
  Function entryFilter = _makePredicate(logFilter);
  String filterName = _qualifiedName(mockNameFilter, logFilter.toString());
  LogEntryList rtn = new LogEntryList(filterName);
  MatchState matchState = new MatchState();
  for (var i = 0; i &lt; logs.length; i++) {
    LogEntry entry = logs[i];
    if (mockNameFilter.matches(entry.mockName, matchState) &amp;&amp;
        entryFilter(entry)) {
      if (actionMatcher == null ||
          actionMatcher.matches(entry, matchState)) {
        rtn.add(entry);
        if (destructive) {
          logs.removeRange(i--, 1);
        }
      }
    }
  }
  return rtn;
}
</pre>
</div>
</div>
<div class="method"><h4 id="last">
<span class="show-code">Code</span>
<strong>get last</strong>() <a class="anchor-link" href="#last"
              title="Permalink to LogEntryList.get last">#</a></h4>
<div class="doc">
<p>Get the last entry, or null if no entries.</p>
<pre class="source">
get last =&gt; (logs == null || logs.length == 0) ? null : logs.last();
</pre>
</div>
</div>
<div class="method"><h4 id="preceding">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>preceding</strong>(<a href="../unittest/LogEntryList.html">LogEntryList</a> keys, [mockNameFilter = null, logFilter = null, int distance = 1, bool includeKeys = false]) <a class="anchor-link" href="#preceding"
              title="Permalink to LogEntryList.preceding">#</a></h4>
<div class="doc">
<p>Iterate through the LogEntryList looking for matches to the entries
in 
<span class="param">keys</span>; for each match found the closest 
<span class="param">distance</span> prior log entries
that match <code>mocknameFilter</code> and 
<span class="param">logFilter</span> will be included in the result.
If 
<span class="param">includeKeys</span> is true then the entries in 
<span class="param">keys</span> that resulted in
entries in the output list are themselves included in the output list. If

<span class="param">distance</span> is zero then all matches are included.</p>
<p>The idea here is that you could find log entries that are related to
other logs entries in some temporal sense. For example, say we have a
method commit() that returns -1 on failure. Before commit() gets called
the value being committed is created by process(). We may want to find
the calls to process() that preceded calls to commit() that failed.
We could do this with:</p>
<pre><code> print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),
     logFilter: callsTo('process')).toString());
</code></pre>
<p>We might want to include the details of the failing calls to commit()
to see what parameters were passed in, in which case we would set

<span class="param">includeKeys</span>.</p>
<p>As another simple example, say we wanted to know the three method
calls that immediately preceded each failing call to commit():</p>
<pre><code>print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),
    distance: 3).toString());
</code></pre>
<pre class="source">
LogEntryList preceding(LogEntryList keys,
                       [mockNameFilter = null,
                       logFilter = null,
                       int distance = 1,
                       bool includeKeys = false]) =&gt;
    _neighboring(true, keys, mockNameFilter, logFilter,
        distance, includeKeys);
</pre>
</div>
</div>
<div class="method"><h4 id="stepwiseValidate">
<span class="show-code">Code</span>
bool <strong>stepwiseValidate</strong>(<a href="../unittest/StepValidator.html">StepValidator</a> validator, [String reason = '']) <a class="anchor-link" href="#stepwiseValidate"
              title="Permalink to LogEntryList.stepwiseValidate">#</a></h4>
<div class="doc">
<p>Iterate through the list and call the 
<span class="param">validator</span> function with the
log <code>List</code> and position. The 
<span class="param">validator</span> should return the number of
positions to advance upon success, or zero upon failure. When zero is
returned an error is reported. 
<span class="param">reason</span> can be used to provide a
more descriptive failure message. If a failure occurred false will be
returned (unless the failure handler itself threw an exception);
otherwise true is returned.
The use case here is to perform more complex validations; for example
we may want to assert that the return value from some function is
later used as a parameter to a following function. If we filter the logs
to include just these two functions we can write a simple validator to
do this check.</p>
<pre class="source">
bool stepwiseValidate(StepValidator validator, [String reason = '']) {
  if (_mockFailureHandler == null) {
    _mockFailureHandler =
        new _MockFailureHandler(getOrCreateExpectFailureHandler());
  }
  var i = 0;
  while (i &lt; logs.length) {
    var n = validator(logs, i);
    if (n == 0) {
      if (reason.length &gt; 0) {
        reason = ': $reason';
      }
      _mockFailureHandler.fail("Stepwise validation failed at $filter "
                               "position $i$reason");
      return false;
    } else {
      i += n;
    }
  }
  return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toString">
<span class="show-code">Code</span>
String <strong>toString</strong>([Date baseTime]) <a class="anchor-link" href="#toString"
              title="Permalink to LogEntryList.toString">#</a></h4>
<div class="doc">
<p>Turn the logs into human-readable text. If 
<span class="param">baseTime</span> is specified
then each entry is prefixed with the offset from that time in
milliseconds; otherwise the time of day is used.</p>
<pre class="source">
String toString([Date baseTime]) {
  String s = '';
  for (var e in logs) {
    s = '$s${e.toString(baseTime)}\n';
  }
  return s;
}
</pre>
</div>
</div>
<div class="method"><h4 id="until">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>until</strong>(Date when, [bool inPlace = false]) <a class="anchor-link" href="#until"
              title="Permalink to LogEntryList.until">#</a></h4>
<div class="doc">
<p>Returns log events that happened until 
<span class="param">when</span>. If 
<span class="param">inPlace</span>
is true, then it returns this LogEntryList after removing
the entries that happened after 
<span class="param">when</span>; otherwise a new
list is created.</p>
<pre class="source">
LogEntryList until(Date when, [bool inPlace = false]) =&gt;
    _head((e) =&gt; e.time &gt; when, inPlace, 'until $when', logs.length);
</pre>
</div>
</div>
<div class="method"><h4 id="untilEntry">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>untilEntry</strong>(<a href="../unittest/LogEntry.html">LogEntry</a> logEntry, [bool inPlace = false]) <a class="anchor-link" href="#untilEntry"
              title="Permalink to LogEntryList.untilEntry">#</a></h4>
<div class="doc">
<p>Returns log events that happened until 
<span class="param">logEntry</span>'s time. If

<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened after <code>when</code>; otherwise a new
list is created. If 
<span class="param">logEntry</span> is null the epoch time is used.</p>
<pre class="source">
LogEntryList untilEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
    until(logEntry == null ?
        new Date.fromMillisecondsSinceEpoch(0) : logEntry.time);
</pre>
</div>
</div>
<div class="method"><h4 id="untilFirst">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>untilFirst</strong>(<a href="../unittest/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#untilFirst"
              title="Permalink to LogEntryList.untilFirst">#</a></h4>
<div class="doc">
<p>Returns log events that happened until the first event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened later; otherwise a new list is created.</p>
<pre class="source">
LogEntryList untilFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
    untilEntry(segment.first, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="untilLast">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>untilLast</strong>(<a href="../unittest/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#untilLast"
              title="Permalink to LogEntryList.untilLast">#</a></h4>
<div class="doc">
<p>Returns log events that happened until the last event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened later; otherwise a new list is created.</p>
<pre class="source">
LogEntryList untilLast(LogEntryList segment, [bool inPlace = false]) =&gt;
    untilEntry(segment.last, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="verify">
<span class="show-code">Code</span>
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>verify</strong>(<a href="../unittest/Matcher.html">Matcher</a> matcher) <a class="anchor-link" href="#verify"
              title="Permalink to LogEntryList.verify">#</a></h4>
<div class="doc">
<p>Apply a unit test <a class="crossref" href="../unittest/Matcher.html">Matcher</a> to the <a class="crossref" href="../unittest/LogEntryList.html#LogEntryList">LogEntryList</a>.</p>
<pre class="source">
LogEntryList verify(Matcher matcher) {
  if (_mockFailureHandler == null) {
    _mockFailureHandler =
        new _MockFailureHandler(getOrCreateExpectFailureHandler());
  }
  expect(logs, matcher, filter, _mockFailureHandler);
  return this;
}
</pre>
</div>
</div>
<h3>Fields</h3>
<div class="field"><h4 id="filter">
<span class="show-code">Code</span>
String         <strong>filter</strong> <a class="anchor-link"
            href="#filter"
            title="Permalink to LogEntryList.filter">#</a>
        </h4>
        <div class="doc">

<pre class="source">
String filter;
</pre>
</div>
</div>
<div class="field"><h4 id="logs">
<span class="show-code">Code</span>
List&lt;<a href="../unittest/LogEntry.html">LogEntry</a>&gt;         <strong>logs</strong> <a class="anchor-link"
            href="#logs"
            title="Permalink to LogEntryList.logs">#</a>
        </h4>
        <div class="doc">

<pre class="source">
List&lt;LogEntry&gt; logs;
</pre>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
